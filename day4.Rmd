# Day 4 lectures and exercises

The following set of commands is for my computer only

```{r internet}
setInternet2(use = FALSE)
# install.packages("knitr",repos="http://rweb.quant.ku.edu/cran/")
library("knitr")
```

## compare the formats

I'm going to use the term "longitudinal" data to designate data sets
where a patient is measured at multiple different time points. This
encompasses certain other data sets, such as from a crossover,
pre-test/post-test, repeated measures, and split plot.

Don't worry about the technical distinctions among these terms. The
important thing to know for now is that longitudinal data represents
one of the biggest challenges in data management and we will spend
most of today discussing these challenges.

Longitudinal data usually come in of two specific formats. The first is the
short and fat format and the second is the tall and thin format. Open these two webpages in Internet explorer to see the difference. 

--> http://www.statsci.org/data/oz/ctsibrm.txt

--> http://www.statsci.org/data/oz/ctsibuni.txt

A description of the context for these files is at

--> http://www.statsci.org/data/oz/ctsib.html

The short and fat format has one row per patient and each successive
patient encounter is strung out horizontally.

The tall and thin format has one row per patient encounter and therefore
multiple rows per patient.

Both formats have advantages and disadvantages, and you need to know how
to create a longitudinal file in either format and how to transform from one format to another.

Short and fat advantages:

1. easy to compute change scores
2. easy to examine correlations over time
3. easy to insure consistency of demographic data

Short and fat disadvantages:

1. hard to read because of the excessive need to scroll left and right

Tall and thin advantages:

1. easy to plot longitudinal trends
2. less need for missing value codes
3. easy to read because most scrolling is up and down

Tall and thin disadvantages

1. hard to maintain consistency of demographic variables

## Converting from short and fat to tall and thin

Here is a data set on termite survival. It is probably a bit of a
stretch to call this longitudinal data, but it still is useful
for illustrating how to convert longitudinal data.

The data is embedded in the description of the file. So you need to strip away the description from the data. It helps to import the data as entire lines, and you do this by specifying a separator character that is not
found anywhere in the file.

```{r read-termites-1}
fi <- "http://lib.stat.cmu.edu/DASL/Datafiles/Termites.html"
te.tst <- read.table(file=fi,sep="~")
te.tst[1:40,]
tail(te.tst)
```

If you look at the first 40 lines, it is obvious that the data starts
somewhere around line 35. and that every previous line (and the very
last line) start with an html tag. The comment argument allows us to
skip any line starting with an html tag. 

Also note the prevalence of "\t" values. These show that the data
itself is a tab-delimited file.

This is one of those cute R tricks that I tend to like, but if you
prefer, you could just cut-and-paste just the lines that you
want from the webpage and store the results in a text editor like
notepad.

```{r read-termites-2}
te <- read.table(file=fi,header=TRUE,comment="<")
head(te)
tail(te)
summary(te)
```

We need to re-organize this data before we can plot it.

```{r tedious-reshape}
sb01 <- te[,c("dish","dose","day1")]
names(sb01)[3] <- "count.living"
sb01$day <- 1
sb01

sb02 <- te[,c("dish","dose","day2")]
names(sb02)[3] <- "count.living"
sb02$day <- 2
sb02

sb04 <- te[,c("dish","dose","day4")]
names(sb04)[3] <- "count.living"
sb04$day <- 4

sb05 <- te[,c("dish","dose","day5")]
names(sb05)[3] <- "count.living"
sb05$day <- 5

sb06 <- te[,c("dish","dose","day6")]
names(sb06)[3] <- "count.living"
sb06$day <- 6

sb07 <- te[,c("dish","dose","day7")]
names(sb07)[3] <- "count.living"
sb07$day <- 7

sb08 <- te[,c("dish","dose","day8")]
names(sb08)[3] <- "count.living"
sb08$day <- 8

sb10 <- te[,c("dish","dose","day10")]
names(sb10)[3] <- "count.living"
sb10$day <- 10

sb11 <- te[,c("dish","dose","day11")]
names(sb11)[3] <- "count.living"
sb11$day <- 11

sb12 <- te[,c("dish","dose","day12")]
names(sb12)[3] <- "count.living"
sb12$day <- 12

sb14 <- te[,c("dish","dose","day14")]
names(sb14)[3] <- "count.living"
sb14$day <- 14

sb15 <- te[,c("dish","dose","day15")]
names(sb15)[3] <- "count.living"
sb15$day <- 15

tea <- rbind(sb01,sb02,sb04,sb05,sb06,sb07,sb08,
                 sb10,sb11,sb12,sb14,sb15)
head(tea)
tail(tea)
```

That's a bit tedious, and a clever R programmer could find a way to use
looping structures like "for" to shorten the code. But there is a
specialized library, reshape2, that makes things even easier.

```{r faster-1}
library("reshape2")
teb <- melt(te,id.vars=c("dish","dose"))
head(teb)
tail(teb)
```

It takes a bit of investigation, but the warning messages refer to
the day3 and day9 values which are character strings. You can fix this by
droping those columns.

```{r faster-2}
tec <- melt(te[,c(-5,-11)],id.vars=c("dish","dose"))
head(tec)
tail(tec)
```

We're not done quite yet. The day of the week is hidden in the variable
called "variable" and we need to keep only the fourth (and maybe fifth)
characters.

```{r substr-1}
substr(tec$variable,4,5)
```

Almost. We need to convert from character to numeric.

```{r substr-2}
tec$day <- as.numeric(substr(tec$variable,4,5))
head(tec)
tail(tec)
```

I'm not too thrilled with the non-descriptive name, value, but
I'm also too lazy here to change it or to drop the now unneeded
column, variable.

Now to plot the data.

```{r plot-termites}
plot(tec$day,tec$value)
```

Let's connect the data for individual subjects.

```{r line-termites}
plot(tec$day,tec$value)
for (i in 1:8) {
  sb <- tec$dish==i&tec$dose==5
  lines(tec$day[sb],tec$value[sb],col="darkred")
  sb <- tec$dish==i&tec$dose==10
  lines(tec$day[sb],tec$value[sb],col="darkgreen")
}
```

If you look at the graph, there are a couple of green lines, which
represent dose=10, but which have mnay more alive at day 15 than even
the dose=5 values. If you look at the original data set, these are
rows 9 and 10, corresponding to the first two dishes in the dose=10
group. This may be okay, but you should check with the people who 
collected the data, if you can.

## A data set on depression after an earthquake (short and fat format)

This data set is described in 
--> http://www.statsci.org/data/general/lomaprie.html


```{r read-earthquake}
fn <- "http://www.statsci.org/data/general/lomaprie.txt"
qu <- read.table(fn,header=TRUE)
qu
```

## On your own

Convert this to a tall and thin format. Draw boxplots.


## A data set on energy consumption (short and fat format)

This data set is described at

--> http://www.statsci.org/data/general/energy.html

```{r read-energy}
fi <- "http://www.statsci.org/data/general/energy.txt"
en <- read.table(fi,header=TRUE)
head(en)
tail(en)
```

## Converting from tall and thin to short and fat

Now let's read in a tall and thin format and convert it to a
short and wide format.

This data set is described at 

--> http://www.statsci.org/data/general/cholest.html

```{r chol-read}
fi <- "http://www.statsci.org/data/general/cholestg.txt"
ch <- read.table(fi,header=TRUE)
head(ch)
tail(ch)
summary(ch)
```

The summary is not too helpful for the first three variables, so 
try the table command instead.

```{r chol-table}
table(ch$patient,useNA="always")
table(ch$group,useNA="always")
table(ch$day,useNA="always")
```

It's still a bit confusing. Why do the first 28 subjects have three
measurements and the last 30 have only one measurement.

```{r chol-crosstabs}
table(ch$patient,ch$day,useNA="always")
table(ch$group,ch$day,useNA="always")
```

Okay, now it's a bit more clear. Each subject has measurements on
three days (2,4,14) for group one, and measurements on an unspecified
day (NA) for group 2.

Let's look at the tedious and the faster way to convert from the tall
and thin to the short and fat format.

The missing value for day is going to cause a lot of grief, and it is
simpler here to change it to a special code, 99.

```{r chol-reshape-1}
ch$day[is.na(ch$day)] <- 99

sb02 <- ch[ch$day==2,c(1,4)]
names(sb02)[2] <- "cholest02"
head(sb02)

sb04 <- ch[ch$day==4,c(1,4)]
names(sb04)[2] <- "cholest04"
head(sb04)

sb14 <- ch[ch$day==14,c(1,4)]
names(sb14)[2] <- "cholest14"
head(sb14)

sb99 <- ch[ch$day==99,c(1,4)]
names(sb99)[2] <- "cholest99"
head(sb99)

me1 <- merge(sb02,sb04,by="patient")
head(me1)
tail(me1)
me2 <- merge(me1,sb14,by="patient")
head(me2)
tail(me2)
me3 <- merge(me2,sb99,by="patient")
head(me3)
tail(me3)
```

Oops! What happened here is that no matches were found and the default
in the merge function is to only include in the merge those rows that
are found in both data sets. This is known as an inner join in database
parlance. You can use the all.x and all.y arguments to use a left join,
right join, or outer join instead.

```{r chol-reshape2}
me3 <- merge(me2,sb99,by="patient",all.x=TRUE,all.y=TRUE)
head(me3)
tail(me3)
```

```{r chol-reshape-3}
ch1 <- melt(ch,id=c("patient","day","group"))
head(ch1)
tail(ch1)
ch2 <- dcast(ch1,patient+group~variable+day)
head(ch2)
tail(ch2)
cor(ch2[,c("cholest_2","cholest_4","cholest_14")])
```

Oops! The missing values hurt us here. Review the help file for cor.

```{r cholest-cor}
cor(ch2[,c("cholest_2","cholest_4","cholest_14")],use="p")
```

## A data set on back pain with two matched control groups

This data set is described in
--> http://www.statsci.org/data/oz/backpain.html

Subjexts were matched by age, height, and weight. How well were they 
matched?

```{r read-match}
fn <- "http://www.statsci.org/data/oz/backpain.txt"
ma <- read.table(fn,header=TRUE)
ma <- ma[,1:6]
head(ma)
tail(ma)
```

## On your own

Convert this to a short and fat format. Let age1 represent the age of
the subject in the pain group, age2 represent the matched subject
in the nopain group, and age3 represent the matched subject in the
sedentary group. Redefine height and weight similarly.

Plot age1 versus age2 and age1 versus age3 to evaluate how closely
the subjects are matched on age. Repeat for height and weight.

## If there is extra time

Here is a very complex data set on stroke.
--> http://www.statsci.org/data/oz/stroke.html

```{read-stroke}
fi <- "http://www.statsci.org/data/oz/stroke.txt"
st <- read.table(fi,header=TRUE)
head(st)
tail(st)
```

## There is no special assignment to be handed in today.

If you have extra time, work on your own data set.
